<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Person Camera (WebGL)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="webglCanvas"></canvas>

    <script>
        // Get WebGL context
        const canvas = document.getElementById("webglCanvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGL not supported!");
        }

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Vertex shader
        const vsSource = `
            attribute vec4 a_position;
            uniform mat4 u_matrix;
            void main() {
                gl_Position = u_matrix * a_position;
            }
        `;

        // Fragment shader
        const fsSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
            }
        `;

        // Compile shaders
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

        // Create shader program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Define cube vertices
        const vertices = new Float32Array([
            -0.5, -0.5, -0.5,   0.5, -0.5, -0.5,   0.5,  0.5, -0.5,  -0.5,  0.5, -0.5,
            -0.5, -0.5,  0.5,   0.5, -0.5,  0.5,   0.5,  0.5,  0.5,  -0.5,  0.5,  0.5
        ]);

        // Index buffer for drawing cube
        const indices = new Uint16Array([
            0, 1, 2,  2, 3, 0,  // Front
            4, 5, 6,  6, 7, 4,  // Back
            0, 1, 5,  5, 4, 0,  // Bottom
            2, 3, 7,  7, 6, 2,  // Top
            1, 2, 6,  6, 5, 1,  // Right
            3, 0, 4,  4, 7, 3   // Left
        ]);

        // Create vertex buffer
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Create index buffer
        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // Link vertex data to shader
        const positionLocation = gl.getAttribLocation(program, "a_position");
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLocation);

        // Get uniform location for transformation matrix
        const matrixLocation = gl.getUniformLocation(program, "u_matrix");

        // Camera properties
        let camera = { x: 0, y: 0, z: -5, angle: 0 };
        const moveSpeed = 0.1;
        const rotationSpeed = 0.05;
        let keys = {};

        // Key event handlers
        document.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

        // 4x4 Matrix helper functions
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0,  0,  0,
                0,  f,  0,  0,
                0,  0,  (far + near) / (near - far),  -1,
                0,  0,  (2 * far * near) / (near - far),  0
            ]);
        }

        function translationMatrix(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }

        function rotationYMatrix(angle) {
            return new Float32Array([
                Math.cos(angle),  0, Math.sin(angle), 0,
                0, 1, 0, 0,
                -Math.sin(angle),  0, Math.cos(angle), 0,
                0, 0, 0, 1
            ]);
        }

        // Game loop
        function update() {
            if (keys["a"]) camera.angle -= rotationSpeed;
            if (keys["d"]) camera.angle += rotationSpeed;

            let moveX = Math.sin(camera.angle) * moveSpeed;
            let moveZ = Math.cos(camera.angle) * moveSpeed;

            if (keys["w"]) { camera.x -= moveX; camera.z += moveZ; }
            if (keys["s"]) { camera.x += moveX; camera.z -= moveZ; }
            if (keys["z"]) camera.y -= moveSpeed;
            if (keys["x"]) camera.y += moveSpeed;

            draw();
            requestAnimationFrame(update);
        }

        // Draw function
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            let perspective = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
            let rotation = rotationYMatrix(camera.angle);
            let translation = translationMatrix(camera.x, camera.y, camera.z);

            let matrix = new Float32Array(16);
            for (let i = 0; i < 16; i++) {
                matrix[i] = perspective[i] + rotation[i] + translation[i];
            }

            gl.uniformMatrix4fv(matrixLocation, false, matrix);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        update();
    </script>
</body>
</html>
